---
title: Introduction to git (and GitHub)
# author: "Alan O'Callaghan"
output:
  xaringan::moon_reader:
    fig_width: 5
    fig_height: 4
---

```{r opts, echo = FALSE}
knitr::opts_chunk$set(
    cache = 0,
    # cache.path = "cache_git/",
    dev = "png",
    out.width = "500px",
    dpi = 300,
    dev.args = list(
        type = "cairo-png"
    ),
    fig.path = "figure_git/"
)
library("ggplot2")
theme_set(theme_bw())
```

<style type = "text/css">
  .remark-code-line {
    font-size: 10pt
  }
</style>

```{bash, echo = FALSE, results = "hide"}
COMMIT=$(git rev-parse HEAD)
```


# Outline

- How do we do common tasks?

- What do we need to know?

- How do you rescue yourself from messy situations?

---

# Disclaimer

I am not really a git expert.

--

I will probably say multiple things that are completely wrong or misleading.

--

I have simply used git for a while, and am willing to look up commands and
occasionally break my repos, which means I am now familiar with git.

--

I still frequently make mistakes when managing repositories.

--

Making mistakes is usually fine, and easily fixable, as long as you follow some
basic rules.

---

# How should you use git?

- Commit often, commit everything

  - Don't *push* everything, though

--

- Branches are cheap and easy

  - Don't work on master/main unless you're the repo is private and/or you're working alone

--

- Pull often, or reap the reward of huge merge conflicts

--

- Reasonably informative commit messages and "atomic" commits are ideal,
  but not always practical

---

# What is a git repo?

Fundamentally, it's just a directory with a special `.git` folder.

The `.git` folder contains every version of all of the files in the repository,
as well as metadata like branches, tags, and remotes.

To add files to git, they first need to be **staged**, then **committed**.

---

# Staging

```{r, echo=FALSE, out.width = "50%"}
knitr::include_graphics("git-add.png")
```
--
```{r, echo=FALSE, out.width = "50%"}
knitr::include_graphics("git-commit-a.png")
```

---

# git demonstrations

The code for this talk is written in a git repo.

The commands I've written
here should mostly work in another repo if you want to follow along.

However I've tried to provide some small exercises to try them out yourself,
so don't feel obliged.

---

# Staging demonstration

```{bash}
echo "my new" > new-file.txt
git status
```

```{bash}
git add new-file.txt
```

--

```{bash}
git status
```

---

# Committing changes

```{bash}
git commit -m "Add new-file.txt"
```

--

Oops! I forgot a word in my initial commit. I'm going to *amend* the commit.

```{bash}
echo "my new file" > new-file.txt
git commit -a --amend -m "Add new-file.txt"
```

--

This is handy for trying to create "atomic" commits, where each commit is a
working version of the code (not always feasible, but ideal).

---

# Committing changes (again)

```{bash}
echo "another new file" > another-new-file.txt
git add . # add all files in the current directory
git commit -m "Add another-new-file.txt"
```

--

Actually, I want to add some emphasis to that new file.
```{bash}
echo "another new file!!!!!" > another-new-file.txt
git commit -am "Make sure people know it's an exciting file"
```

---

# Rolling back changes

Actually, I think my enthusiasm was a bit misplaced.

Let's roll those changes back, so we get back to the original state of the repo.

```{bash}
git reset HEAD~1 # revert the repo to the previous commit, but keep the changes on disk
```

```{bash}
git status
```

---

# Rolling back changes on disk

First, let's see what our unstaged changes are, to be sure we're happy discarding
them.

```{bash}
git diff # view the unstaged changes
```
```{bash}
git restore another-new-file.txt
```
```{bash}
git status
```

---

# Removing untracked changes

Hmm... Maybe a file that just says "my new file" isn't crucial...
or indeed another file that just says "another new file".
Let's roll back to the original state of the repo.

```{bash}
git reset HEAD~2
```
```{bash}
git status
```

--

Okay, let's remove both of those untracked files.
```{bash}
git clean -f # better to use -n/--dry-run, or -i (interactive) to be safe
```

```{bash}
git status
```

Done!

---



# What is a branch?

- A branch is a name that points to a commit
- It is a moving target
  - It points to the most recent commit in a sequence

---

# Local refs to remote branches

```{bash}
git branch
```

```{bash}
git branch -a
```

---

# Managing branches

```{bash}
git branch another-branch
```
--
```{bash}
git switch another-branch
```
--
```{bash}
git switch - # switch to the ref (branch) we were last on
```
```{bash}
git branch -d another-branch
```

--

```{bash}
git switch -c another-quick-branch
git switch -
git branch -d another-quick-branch
```

---

# What is a repository?

A repository is a folder that contains a `.git` folder

The .git folder contains configuration, objects, and refs (???)

---

# What is a remote?

A remote is a repository

Usually this is on a version control provider (GitHub)
It can be a folder on your computer, or a server somewhere else

A remote contains branches, tags, and commits, some of which might also
be on your local machine


---

# Interacting with remotes

```{bash}
git fetch origin
```

```{bash}
git merge origin/master
```

--

```{bash}
git pull origin master
```


---

# Using remotes

```{bash}
git remote add upstream git@github.com:alanocallaghan/git-talk-2.git
git fetch upstream
```
--
```{bash}
git remote show
```
--
```{bash}
git remote show upstream
```
--
```{bash}
git remote remove upstream
```

---

# What is a tag?


- A tag is a name that points to a commit
- It is a static target
  - It points to a specific commit forever (mostly)

---

# How do you self-rescue?

As with all-self rescue, the best way is to avoid getting into trouble in the first place.

It's easiest to save yourself if you commit liberally and push carefully.

Often, `git reset` will come in handy.

`git reset --soft [ref]` will move the branch pointer to ref, with any changes
left staged. 

`git reset --hard` is much more aggressive - it will move the branch pointer

---

# How do you self-rescue?
## Accidentally committed

```{bash}
git log -1 --oneline
```
```{bash}
git show HEAD~1 # view the last commit
```

```{bash}
git reset HEAD~1 # or a specific commit SHA/hash
```

```bash
git add [...]
git commit [...] # commit the changes you really want
```

or, if you realise you did want all those changes after all, you could do

```{bash}
git reset HEAD@{1} # go back to the previous state of the repo, before I reset it
```

---

# What is HEAD@{1}???

Truthfully, you can probably treat that as magic syntax.

Personally, I would instead use the amazing `git reflog` to find a specific
reference that I want to revert to.

Let's see:

```{bash}
git reflog -n 10
```

*that's actually where I found the HEAD@{1} magic syntax*


---

# How do you self-rescue?
## Accidentally committed to the wrong branch

```{bash}
git branch new-branch
# git reset --hard origin/master # origin/master is the remote/branch
```
or, if you can remember some magic
```bash
# git reset ${upstream}
```

then
```{bash}
git switch new-branch
# after it's pushed/merged/done...
git switch -
git branch -d new-branch ## cleaning up the repo
```

---

# How do you self-rescue?
## Accidentally pulled (merge conflict)

---

# How do you self-rescue?
## Accidentally pushed

Here be dragons

Best only done if:

- you're the only person working on the repo
- it's a private repo with a few contributors
- it's required (private/sensitive data, huge files committed)...

Reset HEAD to a previous state

---

# git reflog

```{bash}
git reflog | head -n 10
```

---

# Other actions

git stash
git cherry-pick
git rebase
git reset
git revert
git bisect
git blame
git grep

Splitting history (make a subdirectory into its own repo)
Submodules
Adding a repository as a subdirectory (merging repos)

---

# Erasing history

You probably don't want to do this, but it's possible

reset
rebase
checkout?


---


# Other resources

- Software carpentries git: https://swcarpentry.github.io/git-novice/

- git book: https://git-scm.com/book/

- git internals: https://github.com/pluralsight/git-internals-pdf

```{bash, echo = FALSE, results = "hide"}
git switch master
git reset --soft ${COMMIT}
```

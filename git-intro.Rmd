---
title: Introduction to git (and GitHub)
# author: "Alan O'Callaghan"
output:
  xaringan::moon_reader:
    fig_width: 5
    fig_height: 4
---

```{r opts, echo = FALSE}
knitr::opts_chunk$set(
    cache = 0,
    # cache.path = "cache_git/",
    dev = "png",
    out.width = "500px",
    dpi = 300,
    dev.args = list(
        type = "cairo-png"
    ),
    fig.path = "figure_git/"
)
library("ggplot2")
theme_set(theme_bw())
```

<style type = "text/css">
  .remark-code-line {
    font-size: 10pt
  }
</style>

```{bash, echo = FALSE, results = "hide"}
COMMIT=$(git rev-parse HEAD)
```


# Outline

- How do we do common tasks?

- What do we need to know?

- How do you rescue yourself from messy situations?

---

# How should you use git?

- Commit often, commit everything
  - Don't *push* everything, though

- Branches are cheap and easy
  - Don't work on main unless you're the repo is private and you're working alone

- Pull often, or reap the reward of huge merge conflicts

- Reasonably informative commit messages and "atomic" commits are ideal,
  but not always practical


---

# Staging

```{r, echo=FALSE, out.width = "50%"}
knitr::include_graphics("git-add.png")
```
--
```{r, echo=FALSE, out.width = "50%"}
knitr::include_graphics("git-commit-a.png")
```

---

# Staging demonstration

```{bash}
echo "my new file" > new-file.txt
git status
```

```{bash}
git add new-file.txt
```

```{bash}
git status
```

---

# Committing and rolling back changes

```{bash}
git commit -m "Add new-file.txt"
```

```{bash}
git reset HEAD~1 --hard
# --soft keeps all changes staged
# --mixed (the default) unstages changes
```

---

# Local refs to remote branches

```{bash}
git branch
```

```{bash}
git branch -a
```

---

# Other commands

```{bash}
git fetch origin
```

```{bash}
git merge origin/master
```

```{bash}
git pull origin master
```


git commit
git push

but also

git diff
git log
git show
git fetch
git merge

git switch
git restore


---

# What is a commit?

- A snapshot of your project
- A commit is a pointer to a tree and a pointer to the parent commit(s)
- A tree is a pointer to blobs and other trees
- A blob is a pointer to a file

- git commit --amend

---

# What is a branch?

- A branch is a name that points to a commit
- It is a moving target
  - It points to the most recent commit in a sequence


---

# Managing branches

```{bash}
git branch another-branch
```
--
```{bash}
git switch another-branch
```
--
```{bash}
git switch - # switch to the ref (branch) we were last on
```
```{bash}
git branch -d another-branch
```

--

```{bash}
git switch -c another-quick-branch
git switch -
git branch -d another-quick-branch
```

---

# What is a repository?

A repository is a folder that contains a `.git` folder

The .git folder contains configuration, objects, and refs (???)

---

# What is a remote?

A remote is a repository
Usually this is on a version control provider (GitHub)
It can be a folder on your computer, or a server somewhere else
A remote contains branches, tags, and commits, some of which might also
be on your local machine

---

# Using remotes

```{bash}
git remote add upstream git@github.com:alanocallaghan/git-talk-2.git
git fetch upstream
```
--
```{bash}
git remote show
```
--
```{bash}
git remote show upstream
```
--
```{bash}
git remote remove upstream
```

---

# What is a tag?


- A tag is a name that points to a commit
- It is a static target
  - It points to a specific commit forever (mostly)

---

# How do you self-rescue?

As with all-self rescue, the best way is to avoid getting into trouble in the first place.

It's easiest to save yourself if you commit liberally and push carefully.

Often, `git reset` will come in handy.

`git reset --soft [ref]` will move the branch pointer to ref, with any changes
left staged. 

`git reset --hard` is much more aggressive - it will move the branch pointer

---

# How do you self-rescue?
## Accidentally committed

```{bash}
git log -1 --oneline
```
```{bash}
git reset a1eb83c9949b20418d3a5cf913bde2e6695846c0 # or HEAD~[n]
```
```{bash}
git reset HEAD@{1} # re-add whatever I just committed
```

```bash
git add [...]
git commit
```

---

# How do you self-rescue?
## Accidentally committed to the wrong branch

```{bash}
git branch new-branch
git reset --hard origin/master # origin/master is the remote/branch
```
or, if you can remember some magic
```bash
git reset ${upstream}
```

then
```{bash}
git switch new-branch
git switch -
```

---

# How do you self-rescue?
## Accidentally pulled (merge conflict)

---

# How do you self-rescue?
## Accidentally pushed

Here be dragons

Best only done if:

- you're the only person working on the repo
- it's a private repo with a few contributors
- it's required (private/sensitive data, huge files committed)...

Reset HEAD to a previous state

---

# git reflog

```{bash}
git reflog | head -n 10
```

---

# Other actions

git stash
git cherry-pick
git rebase
git reset
git revert
git bisect
git blame
git grep

Splitting history (make a subdirectory into its own repo)
Submodules
Adding a repository as a subdirectory (merging repos)

---

# Erasing history

You probably don't want to do this, but it's possible

reset
rebase
checkout?


---


# Other resources

- Software carpentries git: https://swcarpentry.github.io/git-novice/

- git book: https://git-scm.com/book/

- git internals: https://github.com/pluralsight/git-internals-pdf

```{bash, echo = FALSE, results = "hide"}
git switch master
git reset --soft ${COMMIT}
```

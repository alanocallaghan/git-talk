---
title: Introduction to git (and GitHub)
# author: "Alan O'Callaghan"
output:
  xaringan::moon_reader:
    fig_width: 5
    fig_height: 4
---

```{r opts, echo = FALSE}
knitr::opts_chunk$set(
    cache = 0,
    # cache.path = "cache_git/",
    dev = "png",
    out.width = "500px",
    dpi = 300,
    dev.args = list(
        type = "cairo-png"
    ),
    fig.path = "figure_git/"
)
library("ggplot2")
theme_set(theme_bw())
```

<style type = "text/css">
  .remark-code-line {
    font-size: 10pt
  }
</style>

```{bash, echo = FALSE, results = "hide"}
COMMIT=$(git rev-parse HEAD)
```

I'm going to write something here that causes merge conflicts.


# Outline

- How do we do common tasks?

- What do we need to know?

- How do you rescue yourself from messy situations?

---

# Disclaimer

I am not really a git expert.

--

I will probably say multiple things that are completely wrong or misleading.

--

I have simply used git for a while, and am willing to look up commands and
occasionally break my repos, which means I am now familiar with git.

--

I still frequently make mistakes when managing repositories.

--

Making mistakes is usually fine, and easily fixable, as long as you follow some
basic rules.

---

# How should you use git?

- Commit often, commit everything

  - Don't *push* everything, though

--

- Branches are cheap and easy

  - Don't work on master/main unless you're the repo is private and/or you're working alone

--

- Pull often, or reap the reward of huge merge conflicts

--

- Reasonably informative commit messages and "atomic" commits are ideal,
  but not always practical

---

# What is a git repo?

Fundamentally, it's just a directory with a special `.git` folder.

The `.git` folder contains every version of all of the files in the repository,
as well as metadata like branches, tags, and remotes.

To add files to git, they first need to be **staged**, then **committed**.

---

# Staging

```{r, echo=FALSE, out.width = "50%"}
knitr::include_graphics("git-add.png")
```
--
```{r, echo=FALSE, out.width = "50%"}
knitr::include_graphics("git-commit-a.png")
```

---

# git demonstrations

The code for this talk is written in a git repo.

The commands I've written
here should mostly work in another repo if you want to follow along.

However I've tried to provide some small exercises to try them out yourself,
so don't feel obliged.

---

# Staging demonstration

```{bash}
echo "my new" > new-file.txt
git status
```

```{bash}
git add new-file.txt
```

I've also written something here for... some reason.

--

```{bash}
git status
```

---

# Committing changes

```{bash}
git commit -m "Add new-file.txt"
```

--

Oops! I forgot a word in my initial commit. I'm going to *amend* the commit.

```{bash}
echo "my new file" > new-file.txt
git commit -a --amend -m "Add new-file.txt"
```

--

This is handy for trying to create "atomic" commits, where each commit is a
working version of the code (not always feasible, but ideal).

---

# Committing changes (again)

```{bash}
echo "another new file" > another-new-file.txt
git add . # add all files in the current directory
git commit -m "Add another-new-file.txt"
```

--

Actually, I want to add some emphasis to that new file.
```{bash}
echo "another new file!!!!!" > another-new-file.txt
git commit -am "Make sure people know it's an exciting file"
```

---

# Rolling back changes

Actually, I think my enthusiasm was a bit misplaced.

Let's roll those changes back, so we get back to the original state of the repo.

```{bash}
git reset HEAD~1 # revert the repo to the previous commit, but keep the changes on disk
```

```{bash}
git status
```

---

# Rolling back changes on disk

First, let's see what our unstaged changes are, to be sure we're happy discarding
them.

```{bash}
git diff # view the unstaged changes
```
Yep, I'm happy to discard those changes.
--
```{bash}
git restore another-new-file.txt # restore the file to the state it was in the last commit
```
```{bash}
git status
```

---

# Removing untracked changes

Hmm... Maybe a file that says "my new file" isn't crucial...
or indeed another file that says "another new file".
Let's roll this back.

```{bash}
git reset HEAD~2 # go back two commits
```
```{bash}
git status
```

--

Okay, let's remove both of those untracked files.
```{bash}
git clean -f # better to use -n/--dry-run, or -i (interactive) to be safe
```

Done!

---

# So, what is a commit anyway?

A commit is a snapshot of the repo.

It has a reference to the previous commit, and a snapshot of the repository.

Commits are referenced by a hash, which is a unique identifier for that commit.

---

# So, what is a commit anyway?

You can find out what the last commit was with:

```{bash}
git log -1
```

And view it with

```{bash}
git show HEAD~1 # or git show [HASH}
```

---

# What is a branch?

If we just used commits, it'd be quite difficult to navigate the repo.

"Which version are you working on?"
"Oh, 410defdd6c6"
"Oh damn, I'm only on fdb0eccf"

Instead, we use branches.

--

A branch is just a name that points to a commit.

It is a moving target.

This means that it points to the most recent commit in a sequence,
and you can *push* commits to it, updating what the branch name points to.

---


# Managing branches

```{bash}
git branch
```

```{bash}
git branch another-branch
```
--
```{bash}
git switch another-branch
```
--
```{bash}
git switch - # switch to the ref (branch) we were last on
```
```{bash}
git branch -d another-branch
```

--

```{bash}
git switch -c another-quick-branch
git switch -
git branch -d another-quick-branch
```

---

# What is a remote?

A remote is just another repository.

Usually this is on a version control provider (GitHub)
It can be a folder on your computer, or a server somewhere else.

A remote contains branches, tags, and commits, some of which might also
be on your local machine. When you *fetch* from a remote, just
as when you *clone* a repository, you should get all of the
commits stored on the remote, as well as any of the branches, tags, etc
(though this might not always be immediately obvious).


---

# Interacting with remotes

```{bash}
git fetch origin
```

```{bash}
git merge origin/master
```

--

```{bash}
git pull origin master
```

---


# Local refs to remote branches

```{bash}
git branch
```

```{bash}
git branch -a
```


---

# Using remotes

```{bash}
git remote add upstream git@github.com:alanocallaghan/git-talk-2.git
git fetch upstream
```
--
```{bash}
git remote show
```
--
```{bash}
git remote show upstream
```
--
```{bash}
git remote remove upstream
```

---

# What is a tag?


- A tag is a name that points to a commit
- It is a static target
  - It points to a specific commit forever (mostly)

---

# How do you self-rescue?

As with all-self rescue, the best way is to avoid getting into trouble in the first place.

It's easiest to save yourself if you commit liberally and push carefully.

Often, `git reset` will come in handy.

`git reset --soft [ref]` will move the branch pointer to ref, with any changes
left staged. 

`git reset --hard` is much more aggressive - it will move the branch pointer

---

# How do you self-rescue?
Accidentally committed

```{bash}
git log -1 --oneline
```
```{bash}
git show HEAD~1 # view the last commit
```

```{bash}
git reset HEAD~1 # or a specific commit SHA/hash
```

```bash
git add [...]
git commit [...] # commit the changes you really want
```

or, if you realise you did want all those changes after all, you could do

```{bash}
git reset HEAD@{1} # go back to the previous state of the repo, before I reset it
```

---

# What is HEAD@{1}???

Truthfully, you can probably treat that as magic syntax.

Personally, I would instead use the amazing `git reflog` to find a specific
reference that I want to revert to.

Let's see:

```{bash}
git reflog -n 10
```

---

# How do you self-rescue?

Accidentally committed to the wrong branch

```{bash}
git branch new-branch
# git reset --hard origin/master # origin/master is the remote/branch
```
or, if you can remember some magic
```bash
# git reset ${upstream}
```

then
```{bash}
git switch new-branch
# after it's pushed/merged/done...
git switch -
git branch -d new-branch ## cleaning up the repo
```

---

# How do you self-rescue?
Accidentally pulled (merge conflict)


---

# How do you self-rescue?

Accidentally pushed changes to a remote

Here be dragons

Best only done if:

- you're the only person working on the repo
- it's a private repo with a few contributors
- it's required (private/sensitive data, huge files committed)...

Reset HEAD to a previous state

---

# git reflog

```{bash}
git reflog | head -n 10
```

---

# Other actions

```bash
git stash # save changes for later, without committing (beware!)
git cherry-pick # copy a commit from one branch to another
git rebase # rewrite history (useful for merge requests, but can be messy!)
git revert # undo a commit
git bisect # advanced, but really useful for finding bugs
git blame
```

---

# Other git magic

Splitting history (make a subdirectory into its own repo)

Adding a repository as a subdirectory (merging repos)

Submodules (repositories within repositories)

These are all relatively easy, but the answers can be better found
on StackOverflow than I can explain right now.

---


# Other resources

- Software carpentries git: https://swcarpentry.github.io/git-novice/

- git book: https://git-scm.com/book/

- git internals: https://github.com/pluralsight/git-internals-pdf

```{bash, echo = FALSE, results = "hide"}
git switch master
git reset --hard ${COMMIT}
```

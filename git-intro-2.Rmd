---
title: Introduction to git (and GitHub)
# author: "Alan O'Callaghan"
output:
  xaringan::moon_reader:
    fig_width: 5
    fig_height: 4
---

```{r opts, echo = FALSE}
knitr::opts_chunk$set(
    cache = 0,
    # cache.path = "cache_git/",
    dev = "png",
    out.width = "500px",
    dpi = 300,
    dev.args = list(
        type = "cairo-png"
    ),
    fig.path = "figure_git/"
)
library("ggplot2")
theme_set(theme_bw())
```

<style type = "text/css">
  .remark-code-line {
    font-size: 10pt
  }
</style>

```{bash, echo = FALSE, results = "hide"}
COMMIT=$(git rev-parse HEAD)
```


# What is a branch?

If we just used commits, it'd be quite difficult to navigate the repo.

"Which version are you working on?"
"Oh, 410defdd6c6"
"Oh damn, I'm only on fdb0eccf"

Instead, we use branches.

--

A branch is just a name that points to a commit.

It is a moving target.

This means that it points to the most recent commit in a sequence,
and you can *push* commits to it, updating what the branch name points to.

This is in contrast to tags, which are fixed targets.

---


# Managing branches

```{bash}
git branch
```

```{bash}
git branch another-branch
```
--
```{bash}
git switch another-branch
```
--
```{bash}
git switch - # switch to the ref (branch) we were last on
```
```{bash}
git branch -d another-branch
```

--

```{bash}
git switch -c another-quick-branch
git switch -
git branch -d another-quick-branch
```

---

# What is a remote?

A remote is just another repository.

Usually this is on a version control provider (GitHub).

It can be a folder on your computer, or a server somewhere else.

A remote contains branches, tags, and commits, some of which might also
be on your local machine.

When you *fetch* from a remote, just
as when you *clone* a repository, you should get all of the
commits stored on the remote, as well as any of the branches, tags, etc
(though this might not always be immediately obvious).


---

# Interacting with remotes

One of the main ways to interact with a remote is to `fetch` updates from it.
This will never edit or delete anything in your repo - from branches to commits to tags.

It will only ever add things!

```{bash}
git fetch origin
```

One side effect of `fetch` is that it will update your local copy of remote branches.
So after fetching, you could merge the latest `master`:

```{bash}
git merge origin/master
```

--

Equivalently, we can do both at once:

```{bash}
git pull origin master
```

---


# Local refs to remote branches

What do I mean by "local copy of remote branches"?

Well, most branches we're concerned with are local branches:

```{bash}
git branch
```

However, git also tracks the branches on the remotes. You can actually view
these local copies alongside your own branches:

```{bash}
git branch --all # or -a
```

Generally, and confusingly, `origin/master` refers to the local copy of the
remote branch, while `origin master` refers to the branch `master` on the remote
`origin`.

---

# Pushing

As well as fetching from remotes, we can also `push` our changes to them.
```{bash}
git switch -c new-branch-with-upstream
echo "Some changes" > a-file.txt
git add a-file.txt
git commit -m "Add a-file.txt"
```
```{bash, error = TRUE}
git push
```
```{bash}
git switch master
git branch -D new-branch-with-upstream # -D force deletes
```

---

# Managing remotes

You can add a remote using `git remote add`:

```{bash}
git remote add upstream git@github.com:/alanocallaghan/git-talk-2.git
git fetch upstream
```

```{bash}
git remote show
```

---

# Managing remotes

```{bash}
git remote show upstream
```
--

You can also edit remotes
```{bash}
git remote remove upstream
git remote set-url origin git@github.com:/alanocallaghan/git-talk.git
```

---

# A final note on remotes

I said earlier:
> Branches are cheap and easy
> Don't work on master/main

Why is this?

--

Well, because branches are easily split off, merged, deleted, updated, it's
much safer to push changes to a branch than to the main branch (`master` or `main`).

--

Any commits that are pushed to the main branch are in the repo forever, until
we rewrite history.

Imagine if you pushed a 10GB file to main --- even after deleting it,
every time somebody cloned the repo, they'd have to download that file!

--

If I push a 10GB file to a non-main branch, it's easier to catch mistakes
like that before they get merged into the main branch.

Any commits (and related objects/files) that are left orphaned (without a branch,
tag, etc, pointing to them) will be deleted by git's garbage collection.

---

# Exercise 2


- Fork the talk repo from https://github.com/alanocallaghan/git-talk.git
- Change the `origin` remote to refer to your fork
- Add a new remote called `upstream` that refers to the original repo
- Fetch from the upstream remote
- Merge the `upstream/instructions` branch.
- Follow the instructions in `instructions.txt` in that branch.

---

# How do you self-rescue?

As with all-self rescue, the best way is to avoid getting into trouble in the first place.

It's easiest to save yourself if you commit liberally and push carefully.

--

Often, `git reset` will come in handy.

--

`git reset --soft [ref]` will move the branch pointer to `ref`, with any changes
left staged. 

--

`git reset --hard [ref]` is much more aggressive - it will move the branch pointer
to `ref` and discard any changes.

--

`git reset [ref]` uses `--mixed`. This moves the branch pointer to `ref`,
and unstage any changes.

---

# How do you self-rescue?
Accidentally committed

```{bash}
git log -1 --oneline
```
```{bash}
git show HEAD~1 # view the last commit
```

---

# How do you self-rescue?
Accidentally committed

```{bash}
git reset HEAD~1 # or a specific commit SHA/hash
```

```bash
git add [...]
git commit [...] # commit the changes you really want
```

or, if you realise you did want all those changes after all, you could do

```{bash}
git reset HEAD@{1} # go back to the previous state of the repo, before I reset it to HEAD~1
```

---

# What is HEAD@{1}???

Truthfully, you can probably treat that as magic syntax.

Personally, I would instead use the amazing `git reflog` to find a specific
reference that I want to revert to.

Let's see:

```{bash}
git reflog -n 10
```

`reflog` is truly indispensable for self-rescue.

---

# How do you self-rescue?

Accidentally committed to the wrong branch

```{bash}
git branch new-branch
# git reset --hard origin/master # origin/master is the remote/branch
```
or, if you can remember some magic
```bash
# git reset ${upstream}
```

then
```{bash}
git switch new-branch
# after it's pushed/merged/done...
git switch -
git branch -d new-branch ## cleaning up the repo
```

---

# How do you self-rescue?
Accidentally pulled (merge conflict)

```{bash}
git fetch origin
```
```{bash, error = TRUE}
git merge origin/messy-branch
```
```{bash}
git status
```

---

# How do you self-rescue?
Accidentally pulled (merge conflict)

The simplest way to get out of this is to abort the merge!
```{bash}
git merge --abort
```

---

# Merge conflicts

The more complex way to deal with merge conflicts is to...

actually resolve the merge conflict, then commit the changes.

Unfortunately I can't help you much with this, it's difficult!

However, pulling often will make them less bad.


---

# How do you self-rescue?
Accidentally pushed changes to a remote.

Here be dragons...

Altering history on a feature branch is generally fine - we're usually working
on these alone, or in small groups.

--

Altering history on `main` or `master` is risky.

If you rewrite history, but I don't, and I push some unrelated changes,
then whatever you removed will be added back in as part of my push.

You need to ensure that
everybody else who can push to the repo is aware of what you're doing,
and is willing to reset to your version - otherwise, the changes will end
up being pushed again, along with big merge conflicts!

---

# How do you self-rescue?
Rewriting history on a remote

Best only done if:

- you're the only person working on the repo
- it's a private repo with a few contributors
- it's required (private/sensitive data, huge files committed)...

The basic process would be something like this:

- Copy the repo to a new location if you're not 100% confident
- Reset to a previous state.
- Double- and triple- check that you've removed whatever you need to remove
- Check again
- `git push --force` to the remote
- Ask other contributors to reset to your version by running something like:
  ```bash
  git fetch origin
  git reset --hard origin/main
  ```
  Of course, because this is a `hard` reset, they will lose any changes ---
  this is why you need to coordinate this kind of action.

---

# Other actions

If people want, I can cover some of the following on another day:

```bash
git mv # as it sounds, move a file
git rm # as it sounds, remove a file
git stash # save changes for later, without committing (beware!)
git cherry-pick # copy a commit from one branch to another
git rebase # rewrite history (useful for merge requests, but can be messy!)
git revert # undo a commit
git bisect # advanced, but really useful for finding bugs
git blame # find when different parts of a file were last changed
# probably easier to use github's blame!
git worktree # have multiple versions of the same repository in different folders
```

---

# Other git magic

It's also possible to do some more advanced things with git, such as:

Splitting history (make a subdirectory into its own repo)

--

Adding a repository as a subdirectory (merging repos)

--

Submodules (repositories within repositories)

--

These are all relatively easy, but the answers can be better found
on StackOverflow than I can explain right now.

---


# Other resources

- Software carpentries git: https://swcarpentry.github.io/git-novice/

- git book: https://git-scm.com/book/

- git internals: https://github.com/pluralsight/git-internals-pdf

```{bash, echo = FALSE, results = "hide"}
git switch master
git reset --hard ${COMMIT}
```
